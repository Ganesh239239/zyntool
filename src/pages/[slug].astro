---
import { getCollection } from 'astro:content';
import MainLayout from '../layouts/MainLayout.astro';

export async function getStaticPaths() {
  const toolEntries = await getCollection('tools');
  return toolEntries.map(entry => ({
    params: { slug: entry.slug || entry.id }, props: { entry },
  }));
}

const { entry } = Astro.props;
const { Content } = await entry.render();
const toolId = entry.slug || entry.id;
---

<MainLayout title={entry.data.title}>
    <div class="tool-header py-5 text-white" style={`background-color: ${entry.data.color}`}>
        <div class="container text-center">
            <h1 class="display-4 fw-bold">{entry.data.title}</h1>
            <p class="lead">{entry.data.description}</p>
        </div>
    </div>

    <div class="container my-5">
        <!-- UPLOAD ZONE -->
        <div id="uploadContainer">
            <div class="uploader-zone p-5 border-dashed text-center bg-light rounded-4 mb-4" onclick="document.getElementById('fileInput').click()" style="cursor:pointer">
                <i class={`fa-solid ${entry.data.icon} fa-4x mb-3`} style={`color: ${entry.data.color}`}></i>
                <h3>Select Images</h3>
                <p>or drop them here</p>
                <input type="file" id="fileInput" hidden accept="image/*" />
            </div>
        </div>

        <!-- PROCESSING AREA (Hidden until file selected) -->
        <div id="processingArea" style="display:none;" class="text-center">
            <div class="preview-card p-4 border rounded shadow-sm mb-4">
                <img id="imagePreview" src="" class="img-fluid rounded mb-3" style="max-height: 400px;" />
                <div id="optionsPanel" class="p-3 bg-light rounded mb-3">
                    <!-- Options for the tool appear here -->
                </div>
                <button id="btnAction" class="btn btn-lg w-100 text-white" style={`background-color: ${entry.data.color}`}>
                    Process {entry.data.title}
                </button>
            </div>
        </div>

        <!-- RESULT AREA (Hidden until processed) -->
        <div id="resultArea" style="display:none;" class="text-center">
            <div class="alert alert-success">Image Processed Successfully!</div>
            <img id="resultImage" src="" class="img-fluid rounded mb-3 border" style="max-height: 400px;" />
            <br />
            <a id="downloadBtn" class="btn btn-dark btn-lg px-5">Download Processed Image</a>
            <br />
            <button class="btn btn-link mt-3" onclick="location.reload()">Process another</button>
        </div>

        <hr class="my-5" />

        <article class="prose mx-auto" style="max-width: 800px;">
            <Content />
        </article>
    </div>

    <!-- CLIENT SIDE SCRIPT -->
   <script is:inline define:vars={{ toolId }}>
    const fileInput = document.getElementById('fileInput');
    const uploadContainer = document.getElementById('uploadContainer');
    const processingArea = document.getElementById('processingArea');
    const imagePreview = document.getElementById('imagePreview');
    const btnAction = document.getElementById('btnAction');
    const resultArea = document.getElementById('resultArea');
    const resultImage = document.getElementById('resultImage');
    const downloadBtn = document.getElementById('downloadBtn');
    const optionsPanel = document.getElementById('optionsPanel');

    let selectedFile = null;
    let cropper = null;
    let currentRotation = 0;

    // 1. DYNAMIC UI OPTIONS
    if (toolId === 'resize-image') {
        optionsPanel.innerHTML = `<div class="row g-2"><div class="col"><label class="small fw-bold">Width</label><input type="number" id="resizeW" class="form-control" value="800"></div><div class="col"><label class="small fw-bold">Height</label><input type="number" id="resizeH" class="form-control" value="600"></div></div>`;
    } else if (toolId === 'rotate-image') {
        optionsPanel.innerHTML = `<button class="btn btn-outline-primary" onclick="window.rotateImg()">Rotate 90° Right</button>`;
        window.rotateImg = () => { currentRotation += 90; imagePreview.style.transform = `rotate(${currentRotation}deg)`; };
    } else if (toolId === 'watermark-image') {
        optionsPanel.innerHTML = `<label class="small fw-bold">Watermark Text</label><input type="text" id="wmText" class="form-control" placeholder="© ZynTool 2025">`;
    } else if (toolId === 'meme-generator') {
        optionsPanel.innerHTML = `<input type="text" id="memeTop" class="form-control mb-2" placeholder="Top Text"><input type="text" id="memeBot" class="form-control" placeholder="Bottom Text">`;
    } else if (toolId === 'blur-image') {
        optionsPanel.innerHTML = `<label class="small fw-bold">Blur Intensity</label><input type="range" id="blurRange" class="form-range" min="0" max="20" value="5">`;
    }

    // 2. FILE SELECTION
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            selectedFile = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                uploadContainer.style.display = 'none';
                processingArea.style.display = 'block';
                if (toolId === 'crop-image') {
                    if(cropper) cropper.destroy();
                    setTimeout(() => { cropper = new Cropper(imagePreview, { viewMode: 1 }); }, 100);
                }
            };
            reader.readAsDataURL(file);
        }
    });

    // 3. MASTER PROCESSING LOGIC
    btnAction.addEventListener('click', async () => {
        btnAction.disabled = true;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        img.src = imagePreview.src;

        await new Promise(r => img.onload = r);

        try {
            let resultBlob;
            let exportType = 'image/png';

            if (toolId === 'compress-image') {
                resultBlob = await imageCompression(selectedFile, { maxSizeMB: 1, initialQuality: 0.6 });
            } 
            else if (toolId === 'crop-image' && cropper) {
                resultBlob = await new Promise(r => cropper.getCroppedCanvas().toBlob(r));
            }
            else {
                // CANVAS BASED TOOLS
                canvas.width = img.width;
                canvas.height = img.height;

                if (toolId === 'rotate-image') {
                    if ((currentRotation / 90) % 2 !== 0) { canvas.width = img.height; canvas.height = img.width; }
                    ctx.translate(canvas.width/2, canvas.height/2);
                    ctx.rotate((currentRotation * Math.PI) / 180);
                    ctx.drawImage(img, -img.width/2, -img.height/2);
                } 
                else if (toolId === 'watermark-image') {
                    ctx.drawImage(img, 0, 0);
                    ctx.font = `${canvas.width/15}px Arial`;
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.textAlign = "center";
                    ctx.fillText(document.getElementById('wmText').value, canvas.width/2, canvas.height - 50);
                }
                else if (toolId === 'meme-generator') {
                    ctx.drawImage(img, 0, 0);
                    ctx.font = `bold ${canvas.width/10}px Impact`;
                    ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = canvas.width/100; ctx.textAlign = "center";
                    const top = document.getElementById('memeTop').value.toUpperCase();
                    const bot = document.getElementById('memeBot').value.toUpperCase();
                    ctx.strokeText(top, canvas.width/2, canvas.width/8); ctx.fillText(top, canvas.width/2, canvas.width/8);
                    ctx.strokeText(bot, canvas.width/2, canvas.height - 40); ctx.fillText(bot, canvas.width/2, canvas.height - 40);
                }
                else if (toolId === 'convert-to-jpg') {
                    ctx.drawImage(img, 0, 0); exportType = 'image/jpeg';
                }
                else {
                    ctx.drawImage(img, 0, 0);
                }
                
                resultBlob = await new Promise(r => canvas.toBlob(r, exportType));
            }

            const url = URL.createObjectURL(resultBlob);
            resultImage.src = url;
            downloadBtn.href = url;
            downloadBtn.download = `zyntool-${toolId}.${exportType.split('/')[1]}`;
            processingArea.style.display = 'none';
            resultArea.style.display = 'block';

        } catch (err) {
            alert('Processing error');
            console.error(err);
        } finally {
            btnAction.disabled = false;
        }
    });
</script>
</Layout>

<style>
    .border-dashed { border: 3px dashed #ccc; transition: 0.3s; }
    .border-dashed:hover { border-color: #4B90FF; background: #f0f7ff !important; }
    .prose h3 { margin-top: 2rem; font-weight: 700; color: #333; }
</style>
